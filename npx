
[4mSequelize CLI [Node: 12.4.0, CLI: 5.5.1, ORM: 5.21.7][24m

Loaded configuration file "src\db\config.json".
Using environment "development".
Executing (default): SELECT 1+1 AS result
Executing (default): CREATE SCHEMA IF NOT EXISTS sequelize_schema;
Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';
Executing (default): CREATE TABLE IF NOT EXISTS "sequelize_schema"."sequelize_meta" ("name" VARCHAR(255) NOT NULL UNIQUE , PRIMARY KEY ("name"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_namespace s WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'sequelize_meta' AND s.oid = t.relnamespace AND s.nspname = 'sequelize_schema' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): SELECT "name" FROM "sequelize_schema"."sequelize_meta" AS "SequelizeMeta" ORDER BY "SequelizeMeta"."name" ASC;
Executing (default): CREATE TABLE IF NOT EXISTS "sequelize_schema"."sequelize_meta" ("name" VARCHAR(255) NOT NULL UNIQUE , PRIMARY KEY ("name"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_namespace s WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'sequelize_meta' AND s.oid = t.relnamespace AND s.nspname = 'sequelize_schema' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): SELECT "name" FROM "sequelize_schema"."sequelize_meta" AS "SequelizeMeta" ORDER BY "SequelizeMeta"."name" ASC;
Executing (default): CREATE TABLE IF NOT EXISTS "sequelize_schema"."sequelize_meta" ("name" VARCHAR(255) NOT NULL UNIQUE , PRIMARY KEY ("name"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_namespace s WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'sequelize_meta' AND s.oid = t.relnamespace AND s.nspname = 'sequelize_schema' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): SELECT "name" FROM "sequelize_schema"."sequelize_meta" AS "SequelizeMeta" ORDER BY "SequelizeMeta"."name" ASC;
== 20191128111899-files: migrating =======
Executing (default): CREATE TABLE IF NOT EXISTS "files" ("id"   BIGSERIAL , "name" VARCHAR(255), "url" VARCHAR(255) NOT NULL, "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY ("id"));
Executing (default): CREATE TABLE IF NOT EXISTS "sequelize_schema"."sequelize_meta" ("name" VARCHAR(255) NOT NULL UNIQUE , PRIMARY KEY ("name"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_namespace s WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'sequelize_meta' AND s.oid = t.relnamespace AND s.nspname = 'sequelize_schema' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): INSERT INTO "sequelize_schema"."sequelize_meta" ("name") VALUES ($1) RETURNING *;
== 20191128111899-files: migrated (0.031s)

Executing (default): CREATE TABLE IF NOT EXISTS "sequelize_schema"."sequelize_meta" ("name" VARCHAR(255) NOT NULL UNIQUE , PRIMARY KEY ("name"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_namespace s WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'sequelize_meta' AND s.oid = t.relnamespace AND s.nspname = 'sequelize_schema' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): SELECT "name" FROM "sequelize_schema"."sequelize_meta" AS "SequelizeMeta" ORDER BY "SequelizeMeta"."name" ASC;
== 20191128111900-create_users: migrating =======
Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_users_status' GROUP BY 1
Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_users_role' GROUP BY 1
Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"   BIGSERIAL , "avatar_id" BIGINT REFERENCES "files" ("id"), "first_name" VARCHAR(255) NOT NULL, "last_name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL UNIQUE, "password" VARCHAR(255) NOT NULL, "status" "public"."enum_users_status" NOT NULL DEFAULT 'pending', "role" "public"."enum_users_role" NOT NULL DEFAULT 'user', "disabled" BOOLEAN NOT NULL DEFAULT false, "birthday_date" TIMESTAMP WITH TIME ZONE NOT NULL, "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY ("id"));
Executing (default): CREATE TABLE IF NOT EXISTS "sequelize_schema"."sequelize_meta" ("name" VARCHAR(255) NOT NULL UNIQUE , PRIMARY KEY ("name"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_namespace s WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'sequelize_meta' AND s.oid = t.relnamespace AND s.nspname = 'sequelize_schema' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): INSERT INTO "sequelize_schema"."sequelize_meta" ("name") VALUES ($1) RETURNING *;
== 20191128111900-create_users: migrated (0.032s)

Executing (default): CREATE TABLE IF NOT EXISTS "sequelize_schema"."sequelize_meta" ("name" VARCHAR(255) NOT NULL UNIQUE , PRIMARY KEY ("name"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_namespace s WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'sequelize_meta' AND s.oid = t.relnamespace AND s.nspname = 'sequelize_schema' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): SELECT "name" FROM "sequelize_schema"."sequelize_meta" AS "SequelizeMeta" ORDER BY "SequelizeMeta"."name" ASC;
== 20191128111901-create_users_keys: migrating =======
Executing (default): CREATE TABLE IF NOT EXISTS "users_keys" ("id"   BIGSERIAL , "user_id" BIGINT NOT NULL REFERENCES "users" ("id"), "key" VARCHAR(255) NOT NULL, "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY ("id"));
Executing (default): CREATE TABLE IF NOT EXISTS "sequelize_schema"."sequelize_meta" ("name" VARCHAR(255) NOT NULL UNIQUE , PRIMARY KEY ("name"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_namespace s WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'sequelize_meta' AND s.oid = t.relnamespace AND s.nspname = 'sequelize_schema' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): INSERT INTO "sequelize_schema"."sequelize_meta" ("name") VALUES ($1) RETURNING *;
== 20191128111901-create_users_keys: migrated (0.018s)

Executing (default): CREATE TABLE IF NOT EXISTS "sequelize_schema"."sequelize_meta" ("name" VARCHAR(255) NOT NULL UNIQUE , PRIMARY KEY ("name"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_namespace s WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'sequelize_meta' AND s.oid = t.relnamespace AND s.nspname = 'sequelize_schema' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): SELECT "name" FROM "sequelize_schema"."sequelize_meta" AS "SequelizeMeta" ORDER BY "SequelizeMeta"."name" ASC;
== 20191128111991-chats: migrating =======
Executing (default): CREATE TABLE IF NOT EXISTS "chats" ("id"   BIGSERIAL , "name" VARCHAR(255) NOT NULL, "description" VARCHAR(255), "logo_id" BIGINT REFERENCES "files" ("id"), "available" BOOLEAN NOT NULL, "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY ("id"));
Executing (default): CREATE TABLE IF NOT EXISTS "sequelize_schema"."sequelize_meta" ("name" VARCHAR(255) NOT NULL UNIQUE , PRIMARY KEY ("name"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_namespace s WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'sequelize_meta' AND s.oid = t.relnamespace AND s.nspname = 'sequelize_schema' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): INSERT INTO "sequelize_schema"."sequelize_meta" ("name") VALUES ($1) RETURNING *;
== 20191128111991-chats: migrated (0.029s)

Executing (default): CREATE TABLE IF NOT EXISTS "sequelize_schema"."sequelize_meta" ("name" VARCHAR(255) NOT NULL UNIQUE , PRIMARY KEY ("name"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_namespace s WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'sequelize_meta' AND s.oid = t.relnamespace AND s.nspname = 'sequelize_schema' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): SELECT "name" FROM "sequelize_schema"."sequelize_meta" AS "SequelizeMeta" ORDER BY "SequelizeMeta"."name" ASC;
== 20200210083038-create_comments: migrating =======
Executing (default): CREATE TABLE IF NOT EXISTS "comments" ("id"   BIGSERIAL , "message" VARCHAR(255) NOT NULL, "user_id" BIGINT REFERENCES "users" ("id"), "chat_id" BIGINT REFERENCES "chats" ("id"), "file_id" BIGINT REFERENCES "files" ("id"), "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY ("id"));
Executing (default): CREATE TABLE IF NOT EXISTS "sequelize_schema"."sequelize_meta" ("name" VARCHAR(255) NOT NULL UNIQUE , PRIMARY KEY ("name"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_namespace s WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'sequelize_meta' AND s.oid = t.relnamespace AND s.nspname = 'sequelize_schema' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): INSERT INTO "sequelize_schema"."sequelize_meta" ("name") VALUES ($1) RETURNING *;
== 20200210083038-create_comments: migrated (0.018s)

Executing (default): CREATE TABLE IF NOT EXISTS "sequelize_schema"."sequelize_meta" ("name" VARCHAR(255) NOT NULL UNIQUE , PRIMARY KEY ("name"));
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_namespace s WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'sequelize_meta' AND s.oid = t.relnamespace AND s.nspname = 'sequelize_schema' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): SELECT "name" FROM "sequelize_schema"."sequelize_meta" AS "SequelizeMeta" ORDER BY "SequelizeMeta"."name" ASC;
== 20200423080835-addUserName: migrating =======
Executing (default): ALTER TABLE "public"."users" ADD COLUMN "user_name" VARCHAR(255) NOT NULL UNIQUE;


